<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>0106-further topics · Introduction to Scientific Programming and Machine Learning with Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Introduction to Scientific Programming and Machine Learning with Julia</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Index</a></li><li><span class="tocitem">Lessons</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">KOM - Kick off meeting</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../00_-_KOM_-_Kickoff_meeting/0000-KOMeeting.html">0000-KOMeeting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">JULIA1 - Basic Julia Programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="0101-basic_syntax.html">0101-basic syntax</a></li><li><a class="tocitem" href="0102-types_and_objects.html">0102-types and objects</a></li><li><a class="tocitem" href="0103-predefined_types.html">0103-predefined types</a></li><li><a class="tocitem" href="0104-control_flow_and_functions.html">0104-control flow and functions</a></li><li><a class="tocitem" href="0105-custom_types.html">0105-custom types</a></li><li class="is-active"><a class="tocitem" href="0106-further_topics.html">0106-further topics</a><ul class="internal"><li><a class="tocitem" href="#Some-stuff-to-set-up-the-environment.."><span>Some stuff to set-up the environment..</span></a></li><li><a class="tocitem" href="#Metaprogramming-and-macros"><span>Metaprogramming and macros</span></a></li><li><a class="tocitem" href="#Interfacing-with-other-languages"><span>Interfacing with other languages</span></a></li><li><a class="tocitem" href="#Some-performance-tips"><span>Some performance tips</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">JULIA2 - Scientific programming with Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../02_-_JULIA2_-_Scientific_programming_with_Julia/0201-WranglingData.html">0201-WranglingData</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Lessons</a></li><li><a class="is-disabled">JULIA1 - Basic Julia Programming</a></li><li class="is-active"><a href="0106-further_topics.html">0106-further topics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="0106-further_topics.html">0106-further topics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/IntroSPMLJuliaCourse/blob/master/lessonsSources/01_-_JULIA1_-_Basic_Julia_programming/0106-further_topics.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre></pre><h1 id="Further-Topics"><a class="docs-heading-anchor" href="#Further-Topics">0106 Further Topics</a><a id="Further-Topics-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Topics" title="Permalink"></a></h1><h2 id="Some-stuff-to-set-up-the-environment.."><a class="docs-heading-anchor" href="#Some-stuff-to-set-up-the-environment..">Some stuff to set-up the environment..</a><a id="Some-stuff-to-set-up-the-environment..-1"></a><a class="docs-heading-anchor-permalink" href="#Some-stuff-to-set-up-the-environment.." title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; cd(@__DIR__)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Pkg</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.activate(&quot;.&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">  Activating project at `~/work/IntroSPMLJuliaCourse/IntroSPMLJuliaCourse/buildedDoc/01_-_JULIA1_-_Basic_Julia_programming`</code></pre><p>If using a Julia version different than 1.7 please uncomment and run the following line (reproductibility guarantee will however be lost) Pkg.resolve() Pkg.instantiate()</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Random</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(123)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using InteractiveUtils # loaded automatically when working... interactively</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h2 id="Metaprogramming-and-macros"><a class="docs-heading-anchor" href="#Metaprogramming-and-macros">Metaprogramming and macros</a><a id="Metaprogramming-and-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Metaprogramming-and-macros" title="Permalink"></a></h2><p>&quot;running&quot; some code include the following passages (roughly):</p><ul><li>parsing of the text defining the code and its translation in hierarchical expressions to the Abstract syntax Tree (AST) (syntax errors are caugth at this time)</li><li>on the first instance required (&quot;just in time&quot;) compilation of the AST expressions into object code (using the LLVM compiler)</li><li>execution of the compiled object code</li></ul><p>&quot;Macros&quot; in many other language (e.g. C or C++) refer to the possibility to &quot;pre-process&quot; the textual representation of the code statements before it is parsed. In julia instead it refers to the possibility to alter the expression once has already being parsed in the AST, allowing a greater expressivity as we are no longer limited by the parsing syntax</p><p>The AST is organised in a hierarchical tree of <em>expressions</em> where each element (including the operators) is a <em>symbol</em> For variables, you can use symbols to refer to the actual identifiers instad to the variable&#39;s value Expressions themselves are objects representing unevaluated computer expressions</p><h3 id="Expressions-and-symbols"><a class="docs-heading-anchor" href="#Expressions-and-symbols">Expressions and symbols</a><a id="Expressions-and-symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions-and-symbols" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr1 = Meta.parse(&quot;a = b + 2&quot;) # What the parser do when reading the source code. b doesn&#39;t need to actually been defined, it&#39;s just a namebinding without the reference to any object, not even `nothing`</code><code class="nohighlight hljs ansi" style="display:block;">:(a = b + 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(expr1) # expressions are first class objects</code><code class="nohighlight hljs ansi" style="display:block;">Expr</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr2 = :(a = b + 1)</code><code class="nohighlight hljs ansi" style="display:block;">:(a = b + 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr3 = quote a = b + 1 end</code><code class="nohighlight hljs ansi" style="display:block;">quote
    #= REPL[4]:1 =#
    a = b + 1
end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr3</code><code class="nohighlight hljs ansi" style="display:block;">quote
    #= REPL[4]:1 =#
    a = b + 1
end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dump(expr1)   # The AST ! Note this is already a nested statement, an assignment of the result of an expression (the sum call between the symbol `:b` and 1) to the symbol `a`</code><code class="nohighlight hljs ansi" style="display:block;">Expr
  head: Symbol =
  args: Array{Any}((2,))
    1: Symbol a
    2: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Symbol b
        3: Int64 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr4 = Expr(:(=),:a,Expr(:call,:+,:b,1)) # The AST using the &quot;Expr&quot; constructor</code><code class="nohighlight hljs ansi" style="display:block;">:(a = b + 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symbol1   = :(a)               # as for expressions</code><code class="nohighlight hljs ansi" style="display:block;">:a</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symbol2   = Meta.parse(&quot;a&quot;)    # as for expressions</code><code class="nohighlight hljs ansi" style="display:block;">:a</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; symbol3   = Symbol(&quot;a&quot;)        # specific for symbols only</code><code class="nohighlight hljs ansi" style="display:block;">:a</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; othsymbol = Symbol(&quot;aaa&quot;,10,&quot;bbb&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">:aaa10bbb</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(symbol1)</code><code class="nohighlight hljs ansi" style="display:block;">Symbol</code></pre><p>I can access any parts of my expression before evaluating it (indeed, that&#39;s what macro will do...)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; myASymbol = expr1.args[2].args[1]</code><code class="nohighlight hljs ansi" style="display:block;">:+</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr1.args[2].args[1] = :(*)</code><code class="nohighlight hljs ansi" style="display:block;">:*</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = 2</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # a # error, a not defined
       eval(expr1)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a # here now is defined and it has an object associated... 4!</code><code class="nohighlight hljs ansi" style="display:block;">4</code></pre><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>The capability to evaluate expressions is very powerfull but due to obvious secutiry implications never evaluate expressions you aren&#39;t sure of their provenience. For example if you develop a Julia web app (e.g. using <a href="https://github.com/GenieFramework/Genie.jl">Genie.jl</a>) never evaluate user provided expressions.</p></div></div><p>Note that evaluation of expressions happens always at global scope, even if it done inside a function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function foo()
           locVar = 1
           expr = :(locVar + 1)
           return eval(expr)
       end</code><code class="nohighlight hljs ansi" style="display:block;">foo (generic function with 1 method)</code></pre><p>To refer to the <em>value</em> of a variable rather than the identifier itself within an expression, interpolate the variable using the dollar sign:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; expr = :($a + b) # here the identifier &#39;a&#39; has been replaced with its numerical value, `4`</code><code class="nohighlight hljs ansi" style="display:block;">:(4 + b)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dump(expr)</code><code class="nohighlight hljs ansi" style="display:block;">Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 4
    3: Symbol b</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(expr)</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 10</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(expr) # no changes</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = 100</code><code class="nohighlight hljs ansi" style="display:block;">100</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(expr) # here it change, as it is at eval time that the identifier `b` is &quot;replaced&quot; with its value</code><code class="nohighlight hljs ansi" style="display:block;">104</code></pre><h3 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h3><p>One of the best usage of macros is they allow package developers to provide a very flexible API to their package, suited for the specific needs of the package, making life easier for the users. Compare for example <a href="https://jump.dev/JuMP.jl/stable/manual/constraints/">the API of JuMP</a> with <a href="https://pyomo.readthedocs.io/en/stable/pyomo_modeling_components/Constraints.html">those of Pyomo</a> to define model constraints !</p><p>Some examples of macros: <a href="https://github.com/sylvaticus/MultiDimEquations.jl">MultiDimEquations.jl</a></p><ul><li>from: <code>@meq par1[d1 in DIM1, d2 in DIM2, dfix3] =  par2[d1,d2]+par3[d1,d2]</code></li><li>to:   <code>[par1[d1,d2,dfix3] =  par2[d1,d2]+par3[d1,d2] for d1 in DIM1, d2 in DIM2]</code></li></ul><p><a href="https://github.com/oxinabox/Pipe.jl">Pipe.jl:</a></p><ul><li>from: <code>@pipe  10 |&gt; foo(_,a) |&gt; foo2(b,_,c) |&gt; foo3(_)</code></li><li>to:   <code>foo3(foo2(b,foo(10,a),c))</code></li></ul><p>Brodcasting (Base):</p><ul><li>from: <code>@. a + b * D^2</code></li><li>to:   <code>a .+ b .* D.^2</code></li></ul><p>Defining a macro...</p><p>Like functions, but both the arguments and the retuned output are expressions</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; macro customLoop(controlExpr,workExpr)
           return quote
             for i in $controlExpr
               $workExpr
             end
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">@customLoop (macro with 1 method)</code></pre><p>Invoking a macro....</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 5</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop 1:4 println(i) #note that &quot;i&quot; is in the macro</code><code class="nohighlight hljs ansi" style="display:block;">1
2
3
4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop 1:a println(i)</code><code class="nohighlight hljs ansi" style="display:block;">1
2
3
4
5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop 1:a if i &gt; 3 println(i) end</code><code class="nohighlight hljs ansi" style="display:block;">4
5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]  println(i)</code><code class="nohighlight hljs ansi" style="display:block;">apple
orange
banana</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @customLoop [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]  begin print(&quot;i: &quot;); println(i)  end</code><code class="nohighlight hljs ansi" style="display:block;">i: apple
i: orange
i: banana</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @macroexpand @customLoop 1:4 println(i) # print what the macro does with the specific expressions provided</code><code class="nohighlight hljs ansi" style="display:block;">quote
    #= REPL[1]:3 =#
    for var&quot;#133#i&quot; = 1:4
        #= REPL[1]:4 =#
        Main.println(var&quot;#133#i&quot;)
    end
end</code></pre><p>String macros (aka &quot;non-standard string literals&quot;) Invoked with the syntax <code>xxx&quot; ...text...&quot;</code> or <code>xxx&quot;&quot;&quot; ...multi-line text...&quot;&quot;&quot;</code> where <code>xxx</code> is the name of the macro and the macro must be defined as <code>macro  xxx_str</code>. Used to perform textual modification o nthe given text, for example this print the given text on a 8 characters</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; macro print8_str(mystr)                                 # input here is a string, not an expression
           limits = collect(1:8:length(mystr))
           for (i,j) in enumerate(limits)
             st = j
             en = i==length(limits) ? length(mystr) : j+7
             println(mystr[st:en])
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">@print8_str (macro with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print8&quot;123456789012345678&quot;</code><code class="nohighlight hljs ansi" style="display:block;">12345678
90123456
78</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print8&quot;&quot;&quot;This is a text that once printed in 8 columns with terminal will be several lines. Ok, no rammar rules relating to carriage returns are emploied here...&quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">This is 
a text t
hat once
 printed
 in 8 co
lumns wi
th termi
nal will
 be seve
ral line
s. Ok, n
o rammar
 rules r
elating 
to carri
age retu
rns are 
emploied
 here...</code></pre><p>While normally used to modify text, string macros are &quot;true&quot; macros:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; macro customLoop_str(str)
           exprs = Meta.parse(str)
           controlExpr,workExpr = exprs.args[1],exprs.args[2]
           return quote
             for i in $controlExpr
               $workExpr
             end
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">@customLoop_str (macro with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; customLoop&quot;&quot;&quot;1:4; println(i)&quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">1
2
3
4</code></pre><h2 id="Interfacing-with-other-languages"><a class="docs-heading-anchor" href="#Interfacing-with-other-languages">Interfacing with other languages</a><a id="Interfacing-with-other-languages-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-with-other-languages" title="Permalink"></a></h2><p>There are 3 ways to interface Julia with programs or libraries wrote in other languages. At the lowest level, Julia allows to directly interface with C or Fortran libraries, and this means, aside using directly libraries written in C, to be able to interface with any programming language that offer also a C interface (R, Python...) Using this low level C Interface, users have created specific packages to interface many languages using a simple, Julian-way syntax. We will see these interfaces for R and Python. Finally, at the highest level, many common packages of other languages have been already &quot;interfaced&quot;, so that the user can use the Julia Package without even knowing that this is an interface for an other package, for example <code>SymPy.jl</code> is a large interface to the Python package <code>SymPy</code>.</p><h3 id="Using-C-libraries"><a class="docs-heading-anchor" href="#Using-C-libraries">Using C libraries</a><a id="Using-C-libraries-1"></a><a class="docs-heading-anchor-permalink" href="#Using-C-libraries" title="Permalink"></a></h3><p>Let&#39;s start by seing how to use a C library. For this example to work you will need to have the GCC compiler installed on your machine First let&#39;s write the header and source C files and write them to the disk:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; cheader = &quot;&quot;&quot;
       extern int get5();
       extern double mySum(float x, float y);
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;extern int get5();\nextern double mySum(float x, float y);\n&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; csource = &quot;&quot;&quot;
       int get5(){
           return 5;
       }
       
       double mySum(float x, float y){
           return x+y;
       }
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;int get5(){\n    return 5;\n}\n\ndouble mySum(float x, float y){\n    return x+y;\n}\n&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; open(f-&gt;write(f,cheader),&quot;myclib.h&quot;,&quot;w&quot;)  # We open a stream to file with the &quot;w&quot; parameter as for &quot;writing&quot;, and we pass the stream to the anonymous function to actually write to the stream. If this funcitons is many lines of code, consider rewriting the `open` statement using a `do` block</code><code class="nohighlight hljs ansi" style="display:block;">58</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; open(f-&gt;write(f,csource),&quot;myclib.c&quot;,&quot;w&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">79</code></pre><p>Now let&#39;s run the command to compile the C code we saved as shared library using gcc, a C compiler. The following example assume that GCC is installed in the machine where this example is run and available as <code>gcc</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; compilationCommand1 = `gcc -o myclib.o -c myclib.c` # the actua lcompilation, note the backticks used to define a command</code><code class="nohighlight hljs ansi" style="display:block;">`gcc -o myclib.o -c myclib.c`</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; compilationCommand2 = `gcc -shared -o libmyclib.so myclib.o -lm -fPIC` # the linking into a shared library</code><code class="nohighlight hljs ansi" style="display:block;">`gcc -shared -o libmyclib.so myclib.o -lm -fPIC`</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; run(compilationCommand1)</code><code class="nohighlight hljs ansi" style="display:block;">Process(`gcc -o myclib.o -c myclib.c`, ProcessExited(0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; run(compilationCommand2)</code><code class="nohighlight hljs ansi" style="display:block;">Process(`gcc -shared -o libmyclib.so myclib.o -lm -fPIC`, ProcessExited(0))</code></pre><p>This should have created the C library <code>libmyclib.so</code> on disk. Let&#39;s gonna use it:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const myclib = joinpath(@__DIR__, &quot;libmyclib.so&quot;)  # we need the full path</code><code class="nohighlight hljs ansi" style="display:block;">&quot;/home/runner/work/IntroSPMLJuliaCourse/IntroSPMLJuliaCourse/buildedDoc/01_-_JULIA1_-_Basic_Julia_programming/libmyclib.so&quot;</code></pre><p>ccall arguments:</p><ol><li>A tuple with the funcion name to call and the library path. For both, if embedded in a variable, the variable must be set constant.</li><li>The Julia type that map to the C type returned by the function.<ul><li><code>int</code> → <code>Int32</code> or <code>Int64</code> (or the easy-to remmeber <code>Cint</code> alias)</li><li><code>float</code> → <code>Float32</code> (or the <code>Cfloat</code> alias)</li><li><code>double</code> → <code>Float64</code> (or the <code>Cdouble</code> alias)</li></ul></li><li>A tuple with the Julia types of the parameters passed to the C function</li><li>Any other argument are the values of the parameter passed</li></ol><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = ccall((:get5,myclib), Int32, ())</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = ccall((:mySum,myclib), Float64, (Float32,Float32), 2.5, 1.5)</code><code class="nohighlight hljs ansi" style="display:block;">4.0</code></pre><p>More details on calling C or Fortran code can be obtained <a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/">in the official Julia documentation</a>.</p><h3 id="Using-Python-in-Julia"><a class="docs-heading-anchor" href="#Using-Python-in-Julia">Using Python in Julia</a><a id="Using-Python-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Python-in-Julia" title="Permalink"></a></h3><p>The &quot;default&quot; way to use Python code in Julia is trough the <a href="https://github.com/JuliaPy/PyCall.jl">PyCall.jl</a> package. It automatically take care of convert between Python types (including numpy arrays) and Julia types (types that can not be converted automatically are converted to the generic <code>PyObject</code> type).</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ENV[&quot;PYTHON&quot;] = &quot;&quot; # will force PyCall to download and use a &quot;private to Julia&quot; (conda based) version of Python. use &quot;/path/to/python&quot; if you want to reuse a version already installed on your system</code><code class="nohighlight hljs ansi" style="display:block;">&quot;&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Pkg</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; #Pkg.add(&quot;PyCall&quot;)
       #Pkg.build(&quot;PyCall&quot;)
       using PyCall</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h4 id="Embed-short-python-snippets-in-Julia"><a class="docs-heading-anchor" href="#Embed-short-python-snippets-in-Julia">Embed short python snippets in Julia</a><a id="Embed-short-python-snippets-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Embed-short-python-snippets-in-Julia" title="Permalink"></a></h4><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; py&quot;&quot;&quot;
       def sumMyArgs (i, j):
         return i+j
       def getNthElement (vec,n):
         return vec[n]
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = py&quot;sumMyArgs&quot;(3,4)             # 7 - here we call the Python object (a function) with Julia parameters</code><code class="nohighlight hljs ansi" style="display:block;">7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = py&quot;getNthElement&quot;([1,2,3],1)   # 2 - attention to the diffferent convention for starting arrays!. Note the Julia Array ahas been converted automatically to a Python list</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = py&quot;getNthElement([1,$a,3],1)&quot;  # 7 - here we interpolate the Python call</code><code class="nohighlight hljs ansi" style="display:block;">7</code></pre><p>Alternativly, use <code>@pyinclude(&quot;pythonScript.py&quot;)</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pythonCode = &quot;&quot;&quot;
       def sumMyArgs (i, j, z):
         return i+j+z
       &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;def sumMyArgs (i, j, z):\n  return i+j+z\n&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; open(f-&gt;write(f,pythonCode),&quot;pythonScript.py&quot;,&quot;w&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">40</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @pyinclude(&quot;pythonScript.py&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = py&quot;sumMyArgs&quot;(3,4,5)</code><code class="nohighlight hljs ansi" style="display:block;">12</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Note thaat the 3 arguments definition of <code>sumMyArgs</code> has <em>replaced</em> the 3-arguments one. This would now error <code>py&quot;sumMyArgs&quot;(3,4)</code></p></div></div><h4 id="Use-Python-libraries"><a class="docs-heading-anchor" href="#Use-Python-libraries">Use Python libraries</a><a id="Use-Python-libraries-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Python-libraries" title="Permalink"></a></h4><p>Add a package to the local Python installation using Conda:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pyimport_conda(&quot;ezodf&quot;, &quot;ezodf&quot;, &quot;conda-forge&quot;) # pyimport_conda(module, package, channel)</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;module &#39;ezodf&#39; from &#39;/home/runner/.julia/conda/3/lib/python3.9/site-packages/ezodf/__init__.py&#39;&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const ez = pyimport(&quot;ezodf&quot;)  # Equiv. of Python `import ezodf as ez`</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;module &#39;ezodf&#39; from &#39;/home/runner/.julia/conda/3/lib/python3.9/site-packages/ezodf/__init__.py&#39;&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; destDoc  = ez.newdoc(doctype=&quot;ods&quot;, filename=&quot;anOdsSheet.ods&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;ezodf.document.PackagedDocument object at 0x7f2d31f5dc10&gt;</code></pre><p>Both <code>ez</code> and <code>destDoc</code> are <code>PyObjects</code> for which we can access attributes and call the methods using the usual <code>obj.method()</code> syntax as we would do in Python</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheet    = ez.Sheet(&quot;Sheet1&quot;, size=(10, 10))</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;ezodf.table.Table object at 0x7f2d31aee520&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; destDoc.sheets.append(sheet)</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;ezodf.table.Table object at 0x7f2d31aee520&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # dcell1 = sheet[(2,3)] # This would error because the index is a tuple. Let&#39;s use directly the `get(obj,key)` function instead:
       dcell1   = get(sheet,(2,3)) # Equiv. of Python `dcell1 = sheet[(2,3)]`. Attention again to Python indexing from zero: this is cell &quot;D3&quot;, not &quot;B3&quot; !</code><code class="nohighlight hljs ansi" style="display:block;">PyObject &lt;ezodf.cells.Cell object at 0x7f2d31aee5b0&gt;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcell1.set_value(&quot;Hello&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; get(sheet,&quot;A9&quot;).set_value(10.5) # Equiv. of Python `sheet[&#39;A9&#39;].set_value(10.5)`</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; destDoc.backup = false</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; destDoc.save()</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h3 id="Using-Julia-in-Python"><a class="docs-heading-anchor" href="#Using-Julia-in-Python">Using Julia in Python</a><a id="Using-Julia-in-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Julia-in-Python" title="Permalink"></a></h3><h4 id="Installation-of-the-Python-package-PyJulia"><a class="docs-heading-anchor" href="#Installation-of-the-Python-package-PyJulia">Installation of the Python package <code>PyJulia</code></a><a id="Installation-of-the-Python-package-PyJulia-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-of-the-Python-package-PyJulia" title="Permalink"></a></h4><p><a href="https://github.com/JuliaPy/pyjulia">PyJulia</a> can be installed using <code>pip</code>, taking note that its name using <code>pip</code> is <code>julia</code> not <code>PyJulia</code>: <code>$ python3 -m pip install --user julia</code></p><p>We can now open a Python terminal and initialise PyJulia to work with our Julia version:</p><pre><code class="language-python hljs">&gt;&gt;&gt; import julia
&gt;&gt;&gt; julia.install() # Only once to set-up in julia the julia packages required by PyJulia</code></pre><p>If we have multiple Julia versions, we can specify the one to use in Python passing julia=&quot;/path/to/julia/binary/executable&quot; (e.g. julia = &quot;/home/myUser/lib/julia-1.1.0/bin/julia&quot;) to the install() function.</p><h4 id="Running-Julia-libraries-and-code-in-Python"><a class="docs-heading-anchor" href="#Running-Julia-libraries-and-code-in-Python">Running Julia libraries and code in Python</a><a id="Running-Julia-libraries-and-code-in-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Julia-libraries-and-code-in-Python" title="Permalink"></a></h4><p>On each Python session we need to run the following code:</p><pre><code class="language-python hljs">from julia import Julia
Julia(compiled_modules=False)</code></pre><p>This is a workaround to the common situation when the Python interpreter is statically linked to libpython, but it will slow down the interactive experience, as it will disable Julia packages pre-compilation, and every time we will use a module for the first time, this will need to be compiled first. Other, more efficient but also more complicate, workarounds are given in the package documentation, under the <a href="https://pyjulia.readthedocs.io/en/stable/troubleshooting.html">Troubleshooting section</a>.</p><p>We can now direcltly load a Julia module, including <code>Main</code>, the global namespace of Julia’s interpreter, with <code>from julia import ModuleToLoad</code> and access the module objects directly or using the <code>Module.evel()</code> interface.</p><p>Add a Julia package...</p><pre><code class="language-python hljs">&gt;&gt;&gt; from julia import Pkg
&gt;&gt;&gt; Pkg.add(&quot;BetaML&quot;)
````
Of course we can add a apckage alternatively from within Julia

&quot;Direct&quot; access of Julia objects...</code></pre><p>python</p><blockquote><blockquote><blockquote><p>from julia import BetaML import numpy as np model = BetaML.buildForest([[1,10],[2,12],[12,1]],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]) predictions = BetaML.predict(model,np.array([[2,9],[13,0]])) predictions</p></blockquote></blockquote></blockquote><p>[{&#39;b&#39;: 0.36666666666666664, &#39;a&#39;: 0.6333333333333333}, {&#39;b&#39;: 0.7333333333333333, &#39;a&#39;: 0.26666666666666666}]</p><pre><code class="nohighlight hljs">
Access using the `eval()` interface...
If we are using the jl.eval() interface, the objects we use must be already known to julia. To pass objects from Python to Julia, we can import the julia Main module (the root module in julia) and assign the needed variables, e.g.
</code></pre><blockquote><blockquote><blockquote><p>X<em>python = [1,2,3,2,4] from julia import Main Main.X</em>julia = X<em>python Main.eval(&#39;BetaML.gini(X</em>julia)&#39;)</p></blockquote></blockquote></blockquote><p>0.7199999999999999</p><blockquote><blockquote><blockquote><p>Main.eval(&quot;&quot;&quot;</p></blockquote></blockquote></blockquote><p>...   function makeProd(x,y) ...       return x*y ...   end ...   &quot;&quot;&quot; ... )</p><blockquote><blockquote><blockquote><p>Main.eval(&quot;makeProd(2,3)&quot;) # or Main.makeProd(2,3)</p></blockquote></blockquote></blockquote><p>``<code>For large scripts instead of using</code>eval()<code>we can equivalently use</code>Main.include(&quot;aJuliaScript.jl&quot;)`</p><h3 id="Using-R-in-Julia"><a class="docs-heading-anchor" href="#Using-R-in-Julia">Using R in Julia</a><a id="Using-R-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Using-R-in-Julia" title="Permalink"></a></h3><h3 id="Using-Julia-in-R"><a class="docs-heading-anchor" href="#Using-Julia-in-R">Using Julia in R</a><a id="Using-Julia-in-R-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Julia-in-R" title="Permalink"></a></h3><h2 id="Some-performance-tips"><a class="docs-heading-anchor" href="#Some-performance-tips">Some performance tips</a><a id="Some-performance-tips-1"></a><a class="docs-heading-anchor-permalink" href="#Some-performance-tips" title="Permalink"></a></h2><p><a href="https://github.com/sylvaticus/IntroSPMLJuliaCourse/blob/master/lessonsSources/01_-_JULIA1_-_Basic_Julia_programming/0106-further_topics.jl">View this file on Github</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="0105-custom_types.html">« 0105-custom types</a><a class="docs-footer-nextpage" href="../02_-_JULIA2_-_Scientific_programming_with_Julia/0201-WranglingData.html">0201-WranglingData »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 4 February 2022 14:17">Friday 4 February 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
