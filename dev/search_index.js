var documenterSearchIndex = {"docs":
[{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"EditURL = \"https://github.com/sylvaticus/IntroSPMLJuliaCourse/blob/main/lessonsSources/02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.jl\"","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"################################################################################\n###  Introduction to Scientific Programming and Machine Learning with Julia  ###\n###                                                                          ###\n### Run each script on a new clean Julia session                             ###\n### GitHub: https://github.com/sylvaticus/IntroSPMLJuliaCourse               ###\n### Licence (apply to all material of the course: scripts, videos, quizes,..)###\n### Creative Commons By Attribution (CC BY 4.0), Antonello Lobianco          ###\n################################################################################","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Data-Wrangling","page":"0201-wrangling data","title":"0201 - Data Wrangling","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Some-stuff-to-set-up-the-environment..","page":"0201-wrangling data","title":"Some stuff to set-up the environment..","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"cd(@__DIR__)\nusing Pkg\nPkg.activate(\".\")","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"If using a Julia version different than 1.7 please uncomment and run the following line (reproductibility guarantee will hower be lost) Pkg.resolve()","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Pkg.instantiate()\nusing Random\nRandom.seed!(123)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Introduction","page":"0201-wrangling data","title":"Introduction","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"This segment will be mostly based on DataFrames and related packages","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"!!! info DataFrames vs Matrix     DataFrames are popular format for in-memory tabular data. Their main advantages over Arrays are that they can efficiently store different types of data on each column (indeed each column is a wrapper over an Array{T,1} where T is specific to each column) and, thanks also to their named columns, provide convenient API for data operations, like indexing, querying , joining, split-apply-combine, etc.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"info: Info\nIn most circunstances we can refer to dataframe columns either by using their name as a string, e.g. \"Region\", or as symbol, e.g. :Region. In the rest of the segment we will use the strings approach.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Data-import","page":"0201-wrangling data","title":"Data import","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Our example: Forest volumes and area by country and year Source: Eurostat; units: forarea: Milion hectars, forvol: Milion cubic metres","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Built-in-solution:-CSV-–-Matrix","page":"0201-wrangling data","title":"Built-in solution: CSV –> Matrix","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"using DelimitedFiles  # in the stdlib\ndata = convert(Array{Float64,2},readdlm(\"data.csv\",';')[2:end,3:end]) # Skip the first 1 row and the first 2 columns - out is a Matrix","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#CSV.jl:-{CSV-file,-hardwritten-data}-–-DataFrame","page":"0201-wrangling data","title":"CSV.jl: {CSV file, hardwritten data} –> DataFrame","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"using CSV, DataFrames\ndata = CSV.read(\"data.csv\",DataFrame) # source, sink, kword options\ndata = CSV.read(\"data.csv\",NamedTuple)\n\ndata = CSV.read(IOBuffer(\"\"\"\nCountry\tYear\tforarea\tforvol\nGermany\t2000\t11.354\t3381\nFrance\t2000\t15.288\t2254.28\nItaly\t2000\t8.36925\t1058.71\nSweden\t2000\t28.163\t3184.67\nGermany\t2020\t11.419\t3663\nFrance\t2020\t17.253\t3055.83\nItaly\t2020\t9.56613\t1424.4\nSweden\t2020\t27.98\t3653.91\n\"\"\"), DataFrame, copycols=true)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Some common CSV.jl options: delim (use '\\t' for tab delimited files), quotechar, openquotechar, closequotechar, escapechar, missingstring, dateformat, append, writeheader, header, newline, quotestrings, decimal, header, normalizenames, datarow, skipto, footerskip, limit, transpose, comment, use_mmap, type, types (e.g. types=Dict(\"fieldFoo\" => Union{Missing,Int64})), typemap, pool, categorical, strict, silencewarnings, ignorerepeated","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#XLSX.jl:-xlsx-{Matrix,-DataFrame}","page":"0201-wrangling data","title":"XLSX.jl: xlsx -> {Matrix, DataFrame}","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"using XLSX\nsheetNames = XLSX.sheetnames(XLSX.readxlsx(\"data.xlsx\"))\ndata = XLSX.readxlsx(\"data.xlsx\")[\"Sheet1\"][\"A1:D9\"]\ndata = XLSX.readxlsx(\"data.xlsx\")[\"Sheet1\"][:]\ndata = XLSX.readdata(\"data.xlsx\", \"Sheet1\", \"A1:D9\")\nXLSX.readtable(\"data.xlsx\", \"Sheet1\") # tuple vector of (data) vectors, vector of symbols, usable as DF constructor\ndata = DataFrame(XLSX.readtable(\"data.xlsx\", \"Sheet1\")...)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#OdsIO.jl:-ods-{Matrix,-DataFrame}","page":"0201-wrangling data","title":"OdsIO.jl: ods -> {Matrix, DataFrame}","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"using OdsIO\nods_read(\"data.ods\";sheetName=\"Sheet1\",retType=\"DataFrame\")\nods_read(\"data.ods\";sheetName=\"Sheet1\",retType=\"Matrix\",range=[(2,3),(9,4)]) # [(tlr,tlc),(brr,brc)]","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#HTTP.jl:-from-internet","page":"0201-wrangling data","title":"HTTP.jl: from internet","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"import HTTP\nusing Pipe, ZipFile, Tar\nurlData = \"https://github.com/sylvaticus/IntroSPMLJuliaCourse/raw/main/lessonsSources/02_-_JULIA2_-_Scientific_programming_with_Julia/data.csv\"\nurlDataZ = \"https://github.com/sylvaticus/IntroSPMLJuliaCourse/raw/main/lessonsSources/02_-_JULIA2_-_Scientific_programming_with_Julia/data.zip\"\n\n\ndata = @pipe HTTP.get(urlData).body        |>\n             replace!(_, UInt8(';') => UInt8(' ')) |>  # if we need to do modifications to the file before importing\n             CSV.File(_, delim=' ')                |>\n             DataFrame;\nnothing #hide","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#ZipFile.jl-:-from-a-single-zipped-csv-file..","page":"0201-wrangling data","title":"ZipFile.jl : from a single zipped csv file..","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"...on disk...","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"data = @pipe ZipFile.Reader(\"data.zip\").files[1] |>\n             CSV.File(read(_), delim=';') |>\n             DataFrame","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"...or on internet:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"data = @pipe HTTP.get(urlDataZ).body       |>\n             IOBuffer(_)                      |>\n             ZipFile.Reader(_).files[1]    |>\n             CSV.File(read(_), delim=';')  |>\n             DataFrame","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#DataFrame-constructor","page":"0201-wrangling data","title":"DataFrame constructor","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"# named tuple of (colName,colData)..\ndata = DataFrame(\n    country = [\"Germany\", \"France\", \"Italy\", \"Sweden\", \"Germany\", \"France\", \"Italy\", \"Sweden\"],\n    year    = [2000,2000,2000,2000,2020,2020,2020,2020],\n    forarea = [11.354, 15.288, 8.36925, 28.163, 11.419, 17.253, 9.56613, 27.98],\n    forvol  = [3381, 2254.28, 1058.71, 3184.67, 3663, 3055.83, 1424.4, 3653.91]\n)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Matrix-DataFrame","page":"0201-wrangling data","title":"Matrix -> DataFrame","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Headers and data separated:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"M = [\"Germany\"\t2000\t11.354\t3381\n     \"France\"\t2000\t15.288\t2254.28\n     \"Italy\"\t2000\t8.36925\t1058.71\n     \"Sweden\"\t2000\t28.163\t3184.67\n     \"Germany\"\t2020\t11.419\t3663\n     \"France\"\t2020\t17.253\t3055.83\n     \"Italy\"\t2020\t9.56613\t1424.4\n     \"Sweden\"\t2020\t27.98\t3653.91]\nheaders = [\"Country\", \"Year\", \"forarea\", \"forvol\"]\n# array of colData arrays, array of headers\ndata = DataFrame([[M[:,i]...] for i in 1:size(M,2)], Symbol.(headers))","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Headers on the first row of the matrix:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"M = [\"Country\"\t\"Year\"\t\"forarea\" \"forvol\"\n     \"Germany\"\t2000\t11.354\t  3381\n     \"France\"\t2000\t15.288\t  2254.28\n     \"Italy\"\t2000\t8.36925\t  1058.71\n     \"Sweden\"\t2000\t28.163\t  3184.67\n     \"Germany\"\t2020\t11.419\t  3663\n     \"France\"\t2020\t17.253\t  3055.83\n     \"Italy\"\t2020\t9.56613\t  1424.4\n     \"Sweden\"\t2020\t27.98\t  3653.91]\ndata = DataFrame([[M[2:end,i]...] for i in 1:size(M,2)], Symbol.(M[1,:])) # note the autorecognision of col types","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Getting-insights-on-the-data","page":"0201-wrangling data","title":"Getting insights on the data","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"In VSCode, we can also use the workpanel for a nice sortable tabular view of a df","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"show(data,allrows=true,allcols=true)\nfirst(data,6)\nlast(data, 6)\ndescribe(data)\nnR,nC = size(data)\nnames(data)\nfor r in eachrow(data)\n    println(r) # note is it a \"DataFrameRow\"\nend\nfor c in eachcol(data)\n    println(c) # an array\n    println(nonmissingtype(eltype(c)))\nend","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Selection-and-querying-data","page":"0201-wrangling data","title":"Selection and querying data","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Column(s)-selection","page":"0201-wrangling data","title":"Column(s) selection","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"In general we can select: (a) by name (strings or symbols) or by position; (b) a single or a vector of columns, (c) copying or making a view (a reference without copying) of the underlying data","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"data[:,[\"Country\",\"Year\"]] # copy, using strings\ndata[!,[:Country,:Year]]   # view, using symbols\ndata.Year                  # equiv. to `data[!,Year]`\ndata[:,1]                  # also `data[!,1]`\ndata[:,Not([\"Year\"])]","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Row(s)-selection","page":"0201-wrangling data","title":"Row(s) selection","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"data[1,:]    # DataFrameRow\ndata[1:3,:]  # DataFrame","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Note rows have no title names as colums do.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Cell(s)-selection","page":"0201-wrangling data","title":"Cell(s) selection","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"data[2,[2,4]]\ndata[2,\"forarea\"]","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Note that the returned selection is:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"an Array{T,1} if it is a single column;\na DataFrameRow (similar in behaviour to a DataFrame) if a single row;\nT if a single cell;\nan other DataFrame otherwise.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Boolean-selection","page":"0201-wrangling data","title":"Boolean selection","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Both rows and column of a DataFrame (but also of an Matrix) can be selected by passing an array of booleans as column or row mask (and, only for Matrices, also a matrix of booleans)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"mask = [false, false, false, false, true, true, true, true]\ndata[mask,:]\nmask = fill(false,nR,nC)\nmask[2:end,2:3] .= true\nmask\n# data[mask] # error !\nMatrix(data)[mask]","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Boolean selection can be used to filter on conditions, e.g.:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"data[data.Year .>= 2020,:]\ndata[[i in [\"France\", \"Italy\"] for i in data.Country] .&& (data.Year .== 2000),:] # note the parhenthesis","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Filtering-using-the-@subset-macro-from-the-DataFramesMacro-package","page":"0201-wrangling data","title":"Filtering using the @subset macro from the DataFramesMacro package","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"using DataFramesMeta\n@subset(data, :Year .> 2010 )\ncolToFilter = :Country\n@subset(data, :Year .> 2010, cols(colToFilter) .== \"France\" ) # Conditions are \"end\" by default. If the column name is embedded in a varaible we eed to use `cols(varname)`","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Filtering-using-the-Query-package","page":"0201-wrangling data","title":"Filtering using the Query package","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"using Query\ndfOut = @from i in data begin # `i` is a single row\n    @where i.Country == \"France\" .&& i.Year >= 2000\n    # Select a group of columns, eventually changing their name:\n    @select {i.Year, FranceForArea=i.forarea} # or just `i` for the whole row\n    @collect DataFrame\nend","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"long but flexible","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Managing-missing-values","page":"0201-wrangling data","title":"Managing missing values","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"tip: Tip\nSee also the section Missingness implementations for a general discussion on missing values","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"df = copy(data)\n# df[3,\"forarea\"]  = missing # Error, type is Flat64, not Union{Float64,Missing}\ndf.forarea = allowmissing(df.forarea) # also disallowmissing\nallowmissing!(df)\ndf[3,\"forarea\"]  = missing\ndf[6,\"forarea\"]   = missing\ndf[6,\"Country\"]  = missing\nnMissings        = length(findall(x -> ismissing(x), df.forarea)) # Count `missing` values in a column.\ndropmissing(df)\ndropmissing(df[:,[\"forarea\",\"forvol\"]])\ncollect(skipmissing(df.forarea))\ncompletecases(df)\ncompletecases(df[!,[\"forarea\",\"forvol\"]])\n[df[ismissing.(df[!,col]), col] .= 0 for col in names(df) if nonmissingtype(eltype(df[!,col])) <: Number] # Replace `missing` with `0` values in all numeric columns, like `Float64` and `Int64`;\n[df[ismissing.(df[!,col]), col] .= \"\" for col in names(df) if nonmissingtype(eltype(df[!,col])) <: AbstractString] # Replace `missing` with `\"\"` values in all string columns;\ndf","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Editing-data","page":"0201-wrangling data","title":"Editing data","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"df = copy(data)\ndf[1,\"forarea\"] = 11.3\ndf[[2,4],\"forarea\"] .= 10\ndf\npush!(df,[\"UK\",2020,5.0,800.0]) # add row\nsort!(df,[\"Country\",\"Year\"], rev=false)\ndf2 = similar(df) # rubish inside\ndf = similar(df,0) # empty a dataframe. The second parameter is the number of rows desired","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Work-on-dataframe-structure","page":"0201-wrangling data","title":"Work on dataframe structure","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"df       = copy(data)\ndf.foo   = [1,2,3,4,5,6,7,8] # existing or new column\ndf.volHa = data.forvol ./ data.forarea\ndf.goo   = Array{Union{Missing,Float64},1}(missing,size(data,1))\nselect!(df,Not([\"foo\",\"volHa\",\"goo\"])) # remove  cols by name\nrename!(df, [\"Country2\", \"Year2\", \"forarea2\", \"forvol2\"])\nrename!(df, Dict(\"Country2\" => \"Country\"))\ndf       = df[:,[\"Year2\", \"Country\",\"forarea2\",\"forvol2\"] ] #  change column order\ninsertcols!(df, 2, :foo => [1,2,3,4,5,6,7,8] ) # insert a column at position 2\n\ndf.namedYear = map(string,df.Year2)\nstringToInt(str) = try parse(Int64, str) catch; return(missing) end; df.Year3 = map(stringToInt, df.namedYear)\n\ndf2 = hcat(df,data,makeunique=true)\ndf3 = copy(data)\ndf4 = vcat(data,df3)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Categorical-data","page":"0201-wrangling data","title":"Categorical data","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"using CategoricalArrays # You may want to consider also PooledArrays\ndf.Year2 = categorical(df.Year2)\ntransform!(df, names(df, AbstractString) .=> categorical, renamecols=false) # transform to categorical all string columns","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"warning: Warning\nAttention that while the memory to store the data decreases, and grouping is way more efficient, filtering with categorical values is not necessarily quicker (indeed it can be a bit slower)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"levels(df.Year2)\nlevels!(df.Country,[\"Sweden\",\"Germany\",\"France\",\"Italy\"]) # Let you define a personalised order, useful for ordered data\nsort(df.Country)\nsort!(df,\"Country\")\ndf.Years2 = unwrap.(df.Year2) # convert a categorical array into a normal one.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Joining-dataframes","page":"0201-wrangling data","title":"Joining dataframes","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"df1,df2 = copy(data),copy(data)\npush!(df1,[\"US\",2020,5.0,1000.0])\npush!(df2,[\"China\",2020,50.0,1000.0])\nrename!(df2,\"Year\"=>\"year\")\ninnerjoin(df1,df2,on=[\"Country\",\"Year\"=>\"year\"],makeunique=true) # common records only","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Also available: leftjoin (all records on left df), rightjoin (all on right df), outerjoin(all records returned), semijoin (like inner join by only with columns from the right df), antijoin (left not on right df) and crossjoin (like the cartesian product, each on the right by each on the left)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Pivoting-data","page":"0201-wrangling data","title":"Pivoting data","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"long and wide are two kind of layout for equivalent representation of tabled data. In a long layout we have each row being an observation of a single variable, and each record is represented as dim1, dim2, ..., value. As the name implies, \"long\" layouts tend to be relativelly long and hard to analyse by an human, but are very easity to handle. At the opposite, A wide layout represents multiple observations on the same row, eventually using multiple horizontal axis as in the next figure (but Julia dataframes handle only a single horizzontal axis):","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"    \n Forest Area  Forest Volumes \n 2000 2020 2000 2020\nGermany 11.35 11.42 3381 3663\nFrance 15.29 17.25 2254 3056","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"_wide layout is easier to visually analise for a human mind but much more hard to analyse in a sistermatic way. We will learn now how to move from one type of layout to the other.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Stacking-columns:-from-*wide*-to-*long*","page":"0201-wrangling data","title":"Stacking columns: from wide to long","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"longDf  = stack(data,[\"forarea\",\"forvol\"])    # we specify the variable to stack (the \"measured\" variables)\nlongDf2 = stack(data,Not([\"Country\",\"Year\"])) # we specify the variables _not_ to stack (the id variables)\nlongDf3 = stack(data)                         # automatically stack all numerical variables\nlongDf == longDf2 == longDf3","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Note how the columns variable and value have been added automatically to host the stachked data","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Unstacking-columns:-from-*wide*-to-*long*","page":"0201-wrangling data","title":"Unstacking columns: from wide to long","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"wideDf = unstack(longDf,[\"Country\",\"Year\"],\"variable\",\"value\") # args: df, [cols to remains cols also in the wide layout], column with the ids to expand horizontally and column with the relative values\nwideDf2 = unstack(longDf,\"variable\",\"value\") # cols to remains cols also in the wide layout omitted: all cols not to expand and relative value col remains as col\nwideDf == wideDf2 == data","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"While the DataFrames package doesn't support multiple axis we can still arrive to the table below with a little bit of work by unstacking different columns in separate wide dataframes and then joining or horizontally concatenating them:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"wideArea = unstack(data,\"Country\",\"Year\",\"forarea\")\nwideVols = unstack(data,\"Country\",\"Year\",\"forvol\")\nrename!(wideArea,[\"Country\",\"area_2000\",\"area_2020\"])\nrename!(wideVols,[\"Country\",\"vol_2000\",\"vol_2020\"])\nwideWideDf = outerjoin(wideArea,wideVols,on=\"Country\")","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#The-Split-Apply-Combine-strategy","page":"0201-wrangling data","title":"The Split-Apply-Combine strategy","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Aka \"divide and conquer\". Rather than try to modify the dataset direclty, we first split it in subparts, we work on each subpart and then we recombine them in a target dataset","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"using Statistics # for `mean`\ngroupby(data,[\"Country\",\"Year\"]) # The \"split\" part","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Aggregation:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"combine(groupby(data,[\"Year\"]) ,  \"forarea\" => sum => \"sum_area\", \"forvol\" => sum => \"sum_vol\", nrow)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"...or...","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"combine(groupby(data,[\"Year\"])) do subdf # slower\n    (sumarea = sum(subdf.forarea), sumvol = sum(subdf.forvol), nCountries = size(subdf,1))\nend","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Cumulative computation:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"a = combine(groupby(data,[\"Year\"])) do subdf # slower\n    (country = subdf.Country, area = subdf.forarea, cumArea = cumsum(subdf.forarea))\nend","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"Note in these examples that while in the aggregation we was returning a single record for each subgroup (hence we did some dimensionality reduction) in the cumulative compuation we still output the whole subgroup, so the combined dataframe in output has the same number of rows as the original dataframe.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"An alternative approach is to use the @linq macro from the DatAFrameMEta package that provide a R's dplyr-like query language using piped data:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"using DataFramesMeta\ndfCum = @linq data |>\n            groupby([:Year]) |>\n            transform(:cumArea = cumsum(:forarea))","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Export-and-saving","page":"0201-wrangling data","title":"Export and saving","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#DataFrame-to-Matrix","page":"0201-wrangling data","title":"DataFrame to Matrix","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"M = Matrix(data)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"warning: Warning\nAttention that if the dataframe contains different types across columns, the inner type of the matrix will be Any","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"M = Matrix{Union{Float64,Int64,String}}(data)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#DataFrame-to-Dictionary","page":"0201-wrangling data","title":"DataFrame to Dictionary","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"function toDict(df, dimCols, valueCol)\n    toReturn = Dict()\n    for r in eachrow(df)\n        keyValues = []\n        [push!(keyValues,r[d]) for d in dimCols]\n        toReturn[(keyValues...,)] = r[valueCol]\n    end\n    return toReturn\nend\ndict = toDict(data,[\"Country\",\"Year\"],[\"forarea\",\"forvol\"])\ndict[\"Germany\",2000][1]\ndict[\"Germany\",2000][\"forvol\"]\ntoDict(data,[\"Country\",\"Year\"],\"forarea\")","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#DataFrame-to-NamedTuple","page":"0201-wrangling data","title":"DataFrame to NamedTuple","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"nT = NamedTuple(Dict([Symbol(c) => data[:,c]  for c in names(data)]))        # order not necessarily preserved\nusing DataStructures\nnT = NamedTuple(OrderedDict([Symbol(c) => data[:,c]  for c in names(data)])) # order preserved","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Saving-as-CSV-file","page":"0201-wrangling data","title":"Saving as CSV file","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"CSV.write(\"outdata.csv\",data) # see options at the beginning of segment in the import section and `? CSV.write` for specific export options","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Saving-as-OpenDocument-spreadsheet","page":"0201-wrangling data","title":"Saving as OpenDocument spreadsheet","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"ods_write(\"outdata.ods\",Dict((\"myData\",3,2) => data)) # exported starting on cell B3 of sheet \"myData\"","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html#Saving-as-Excel-spreadsheet","page":"0201-wrangling data","title":"Saving as Excel spreadsheet","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"XLSX.writetable(\"outdata.xlsx\",myData = (collect(eachcol(data)),names(data)))","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"View this file on Github.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0201-wrangling_data.html","page":"0201-wrangling data","title":"0201-wrangling data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"EditURL = \"https://github.com/sylvaticus/IntroSPMLJuliaCourse/blob/main/lessonsSources/02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.jl\"","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"################################################################################\n###  Introduction to Scientific Programming and Machine Learning with Julia  ###\n###                                                                          ###\n### Run each script on a new clean Julia session                             ###\n### GitHub: https://github.com/sylvaticus/IntroSPMLJuliaCourse               ###\n### Licence (apply to all material of the course: scripts, videos, quizes,..)###\n### Creative Commons By Attribution (CC BY 4.0), Antonello Lobianco          ###\n################################################################################","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Further-Topics","page":"0202-further topics","title":"0202 - Further Topics","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Some-stuff-to-set-up-the-environment..","page":"0202-further topics","title":"Some stuff to set-up the environment..","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"cd(@__DIR__)\nusing Pkg\nPkg.activate(\".\")","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"If using a Julia version different than 1.7 please uncomment and run the following line (reproductibility guarantee will hower be lost) Pkg.resolve() Pkg.instantiate() # run this if you didn't in Segment 02.01","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"using Random\nRandom.seed!(123)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Plotting","page":"0202-further topics","title":"Plotting","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Within the many possible packages to plot in Julia we use here the Plots package that allows at run time to choose the plot's backend. The defauld backend is gr (that, if you want to go back to it after you choosen another backend, you can activate with gr()). Other common backends are the Python MatplotLib (pyplot(), requiring package PyPlot) and Plotly (plotlyjs() from package PlotlyJS). Actually we use StatsPlots that just adds a set of convenient functionalities (in plots terminology called \"recipes\") on top of Plots.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"using StatsPlots # no need to `using Plots` as `Plots` elements are reexported by StatsPlots","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"The basic idea is that we can draw different \"graphical elements\" in a Plot figure. The plot(.) function will first create a new figure, while plot!(.) will modify an existing plot (by drawing new elements on it, such as a new serie) taking the \"current\" plot as default if no plot object is passed as first argument.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Plotting-functions","page":"0202-further topics","title":"Plotting functions","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Let's start plotting a function. The FIRST TIME you invoke plot will take a while. This is the famous \"time to first plot\" problem due to the JIT compilation, but it refer only to the first plotting in a working session","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"plot(cos) # default [-5,+5] range\nplot!(x->x^2, -2,2 ) # more explicit, with ranges\nplot!(x->max(x,2), label=\"max function\", linestyle=:dot, color=:black, title=\"Chart title\", xlabel= \"X axis\", ylabel=\"Y axis\", legend=:topleft) # a bit of design\nplot!(twinx(),x->20x,colour=RGB(20/255,120/255,13/255)) # secondary axis","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Plotting-data","page":"0202-further topics","title":"Plotting data","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"using DataFrames\nx = 11:15\ndata = DataFrame(a=[4,8,6,6,3], b=[2,4,5,8,6], c=[20,40,15,5,30])\nplot(x, Matrix(data)) # x, series (in column)\n@df data plot(x, :a, seriestype=:bar, legend=:topleft)\nplot!(x, data.b, seriestype=:line)\nscatter!(twinx(), x, data.c) # alias for `plot!(..., seriestype=:scatter)`","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Layouts-with-multiple-plots","page":"0202-further topics","title":"Layouts with multiple plots","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"l = @layout [a ; b c] # a,b,c, here are just placeholders, not related with the df column names..\np1 = plot(x, data.a)\np2 = scatter(x, data.b)\np3 = plot(x, data.c)\nplot(p1, p2, p3, layout = l)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Saving-the-plot..","page":"0202-further topics","title":"Saving the plot..","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"savefig(\"myplot.png\")\nsavefig(\"myplot.pdf\")\nsavefig(\"myplot.svg\")","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Probabilistic-analysis","page":"0202-further topics","title":"Probabilistic analysis","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Julia has a very elegant package to deal with probability analysis, the Distributions package.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"using Distributions","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"The idea is that we first create a Distribution object, of the distribution family and with the parameter required, and then we operate on it, for example to sample or to retrieve a quantile. The following table gives the distribution constructors for some of the most common distributions:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Discrete distr. Constructor Continuous distr. Constructor\nDiscrete uniform DiscreteUniform(lRange,uRange) Uniform Uniform(lRange,uRange)\nBernoulli Bernoulli(p) Exponential Exponential(rate)\nBinomial Binomial(n,p) Laplace Laplace(loc, scale)\nCategorical Categorical(ps) Normal Normal(μ,σ)\nMultinomial Multinomial(n, ps) Erlang Erlang(n,rate)\nGeometric Geometric(p) Cauchy Cauchy(μ, σ)\nHypergeometric Hypergeometric(nS, nF, nTrials) Chisq Chisq(df)\nPoisson Poisson(rate) T Dist TDist(df)\nNegative Binomial NegativeBinomial(nSucc,p) F Dist FDist(df1, df2)\n  Beta Dist Beta(shapeα,shapeβ)\n  Gamma Dist Gamma(shapeα,1/rateβ)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"d = Normal(10,3) # note that the parameter is the standard deviation, not the variance\n\nmean(d)\nvar(d)\nmedian(d)\nquantile(d,0.9)\ncdf(d,13.844)\npdf(d,0)\nsample = rand(d,1000)\nrand(d,10,2,3)\n\ndensity(sample)\nplot!(d)\nfit(Normal, sample) # using MLE","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Curve-fitting","page":"0202-further topics","title":"Curve fitting","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"LsqFit is a very flexible data fitting package for linear and nonlinear arbitrary functions (using least squares). Let's use it to fit a logistic growth curve (Verhulst model) of volumes for a forest stand.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"using LsqFit\ndata = DataFrame(\n    age = 20:5:90,\n    vol = [64,112,170,231,293,352,408,459,505,546,582,613,640,663,683]\n) # Scots Pine, data from the UK Forestry Commission https://web.archive.org/web/20170119072737/http://forestry.gov.uk/pdf/FCBK048.pdf/$FILE/FCBK048.pdf\nplot(data.vol)\n\nlogisticModel(age,parameters) = parameters[1]/(1+exp(-parameters[2] * (age-parameters[3]) ))\nlogisticModelVec(age,parameters) = logisticModel.(age,Ref(parameters))\n\ninitialParameters = [1000,0.02,50] #max growth; growth rate, mid age\nfitobject         = curve_fit(logisticModelVec, data.age, data.vol, initialParameters)\nfitparams         = fitobject.param\n\nfitobject.resid\nresiduals = logisticModelVec(data.age,fitparams) .- data.vol\nfitobject.resid == residuals\n\nsigma            = stderror(fitobject)\nconfidence_inter = confidence_interval(fitobject, 0.05) # 5% significance level\n\nx = 0:maximum(data.age)*1.5\nplot(x->logisticModel(x,fitparams),0,maximum(x), label= \"Fitted vols\", legend=:topleft)\nplot!(data.age, data.vol, seriestype=:scatter, label = \"Obs vols\")\nplot!(data.age, residuals, seriestype=:bar, label = \"Residuals\")","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Constrained-optimisation","page":"0202-further topics","title":"Constrained optimisation","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"JuMP is the leading library to express complex optimisation problems in a clear, mathematical friendly syntax, compute the information required by the solver engines to solve the optimisatio nproblem, pass the problem to the aforementioned solver engines and retrieve the solutions.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"JuMP has the same flexibility and expressivity of dedicated algeabric modelling languages as GAMS or AMPL but with the advantage of being a library within a much more general programming language, with larger community, development tools, language constructs and possibility to interface the specific \"optimisation component\" of a model with the rest of the model.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"We will see how to specify the variables, the constraints and the objective function of an optimisation model, how to \"solve\" it and how to retrieve the optimal values","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#A-linear-example:-the-classical-\"transport\"-problem","page":"0202-further topics","title":"A linear example: the classical \"transport\" problem","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Obj: minimise transport costs c from several plants p to several markets m under the contraint to satisfy the demand d_m at each market while respecting the production capacity c_p of each plant: min_x_pm sum_p sum_m c_pm * x_pm subject to: sum_m x_pm leq d_m sum_p x_pm geq c_m","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"using  JuMP, GLPK, DataFrames, CSV","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#\"Sets\"-and-exogenous-parameters-definition","page":"0202-further topics","title":"\"Sets\" and exogenous parameters definition","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"index sets","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"orig = [\"Epinal\", \"Bordeaux\", \"Grenoble\"] # plant/sawmills origin of timber\ndest = [\"Paris\", \"Lyon\", \"Nantes\", \"Tulouse\", \"Lille\", \"Marseille\", \"Strasbourg\"] # markets\nprod = [\"Fuelwood\", \"Sawnwood\", \"Pannels\"]","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Read input data into DataFrames and then into Dictionaries with 2D or 3D tuples of index sets as keys","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"supply(prod, orig) amounts available at origins","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"supplytable = CSV.read(IOBuffer(\"\"\"\nprod     Epinal Bordeaux Grenoble\nFuelwood 400    700      800\nSawnwood 800    1600     1800\nPannels  200    300      300\n\"\"\"), DataFrame, delim=\" \", ignorerepeated=true,copycols=true)\nsupply = Dict( (r[:prod],o) => r[Symbol(o)] for r in eachrow(supplytable), o in orig)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"demand(prod, dest) amounts required at destinations","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"demandtable = CSV.read(IOBuffer(\"\"\"\nprod      Paris Lyon Nantes Tulouse Lille Marseille Strasbourg\nFuelwood  300   300  100    75      650   225       250\nSawnwood  500   750  400    250     950   850       500\nPannels   100   100  0      50      200   100       250\n\"\"\"), DataFrame, delim=\" \", ignorerepeated=true,copycols=true)\ndemand = Dict( (r[:prod],d) => r[Symbol(d)] for r in eachrow(demandtable), d in dest)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"limit(orig, dest) of total units from any origin to destination","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"defaultlimit = 625.0\nlimit = Dict((o,d) => defaultlimit for o in orig, d in dest)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"cost(prod, orig, dest) Shipment cost per unit","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"costtable = CSV.read(IOBuffer(\"\"\"\nprod     orig     Paris Lyon Nantes Tulouse Lille Marseille Strasbourg\nFuelwood Epinal   30    10   8      10      11    71        6\nFuelwood Bordeaux 22    7    10     7       21    82        13\nFuelwood Grenoble 19    11   12     10      25    83        15\n\nSawnwood Epinal   39    14   11     14      16    82        8\nSawnwood Bordeaux 27    9    12     9       26    95        17\nSawnwood Grenoble 24    14   17     13      28    99        20\n\nPannels  Epinal   41    15   12     16      17    86        8\nPannels  Bordeaux 29    9    13     9       28    99        18\nPannels  Grenoble 26    14   17     13      31    104       20\n\"\"\"), DataFrame, delim=\" \", ignorerepeated=true,copycols=true)\ncost = Dict( (r[:prod],r[:orig],d) => r[Symbol(d)] for r in eachrow(costtable), d in dest)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Optimisation-model-definition","page":"0202-further topics","title":"Optimisation model definition","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"trmodel = Model(GLPK.Optimizer)\nset_optimizer_attribute(trmodel, \"msg_lev\", GLPK.GLP_MSG_ON)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Model's-endogenous-variables-definition","page":"0202-further topics","title":"Model's endogenous variables definition","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"@variables trmodel begin\n    x[p in prod, o in orig, d in dest] >= 0\nend","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Constraints-definition","page":"0202-further topics","title":"Constraints definition","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"@constraints trmodel begin\n    supply[p in prod, o in orig], # observe supply limit at plant/sawmill origin o\n        sum(x[p,o,d] for d in dest) <= supply[p,o]\n    demand[p in prod, d in dest], # satisfy demand at market dest d\n        sum(x[p,o,d] for o in orig) >= demand[p,d]\n    c_total_shipment[o in orig, d in dest],\n        sum(x[p,o,d] for p in prod) <= limit[o,d]\nend","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Objective-function-definition","page":"0202-further topics","title":"Objective function definition","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"@objective trmodel Min begin\n    sum(cost[p,o,d] * x[p,o,d] for p in prod, o in orig, d in dest)\nend","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Human-readable-visualisatio-nof-the-model","page":"0202-further topics","title":"Human-readable visualisatio nof the model","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"print(trmodel)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Model-resolution","page":"0202-further topics","title":"Model resolution","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"optimize!(trmodel)\nstatus = termination_status(trmodel)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#Post-resolution-information-retrieval","page":"0202-further topics","title":"Post-resolution information retrieval","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Here, after the model has been \"solved\", we can retrieve information as the optimal level of the endogenous variables, the value of the opjective function at these optimal levels and the shadow costs of the contraints.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"if (status == MOI.OPTIMAL || status == MOI.LOCALLY_SOLVED || status == MOI.TIME_LIMIT) && has_values(trmodel)\n    println(\"#################################################################\")\n    if (status == MOI.OPTIMAL)\n        println(\"** Problem solved correctly **\")\n    else\n        println(\"** Problem returned a (possibly suboptimal) solution **\")\n    end\n    println(\"- Objective value (total costs): \", objective_value(trmodel))\n    println(\"- Optimal routes:\\n\")\n    optRoutes = value.(x)\n    for p in prod\n      println(\"\\n* $(p):\")\n      [println(\"$o --> $d: $(optRoutes[p,o,d])\") for o in orig, d in dest]\n      println(\"- Shadow prices of supply:\")\n      [println(\"$o = $(dual(supply[p,o]))\") for o in orig]\n      println(\"- Shadow prices of demand:\")\n      [println(\"$d = $(dual(demand[p,d]))\") for d in dest]\n    end\nelse\n    println(\"The model was not solved correctly.\")\n    println(status)\nend","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html#A-nonlinear-example:-portfolio-optimisation","page":"0202-further topics","title":"A nonlinear example: portfolio optimisation","text":"","category":"section"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"The problem objective is to choose the shares of different assets in the portfolio (here forest species, but the example is exactly the same considering other assets, for example financial investments) that maximise the portfolio expected returns while minimising its expected variance under the portfolio owner risk aversion risk. Here the \"returns\" are based on the timber production and the covariance between individual species of the portfolio is based on the observed volume growth covariances. The idea is that within the infinite possible allocations, the locus of those allocations for which is not possible to increase the portfolio profitability without increasing also its variance and the converse whose variance can not be lowered without at the same time lower its expected profitability are efficient in the Pareto meaning and form an \"efficient frontier\". Within this frontier the problem is to find the unique point that maximise the utility of the portfolio's owner given its risk aversion characteristic. Graphically the problem is depicted i nthe following picture:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"(Image: The efficient frontier and the owner utility curves)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Data originally from the Institut national de l'information géographique et forestière (IGN) of France. See the paper A. Dragicevic, A. Lobianco, A. Leblois (2016), ”Forest planning and productivity-risk trade-off through the Markowitz mean-variance model“, Forest Policy and Economics, Volume 64 for a thorough discussion of this model.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Declare the packages we are going to use:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"using JuMP, Ipopt, StatsPlots","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Forest species names","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"species   = [\"Chêne pédonculé\", \"Chêne sessile\", \"Hêtre\", \"Pin sylvestre\"]\nnSpecies  = length(species)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Average productiities by specie This is implemented in a dictionary: key->value","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"y   = Dict( \"Chêne pédonculé\" => 1.83933333333333,\n            \"Chêne sessile\"   => 2.198,\n            \"Hêtre\"           => 3.286,\n            \"Pin sylvestre\"   => 3.3695)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Covariance matrix between species","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"σtable = [[0.037502535947712\t0.016082745098039\t0.027797176470588\t-0.025589882352942]\n          [0.016082745098039\t0.015177019607843\t0.018791960784314\t-0.102880470588234]\n          [0.027797176470588\t0.018791960784314\t0.031732078431373\t-0.166391058823529]\n          [-0.025589882352942\t-0.102880470588234\t-0.166391058823529\t2.02950454411765]]","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"We reshape the covariance matrix in a dictionary (sp1,sp2) -> value The function (ix,x) = enumerate(X) returns a tuple of index position and element for each element of an array","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"σ = Dict((i,j) => σtable[i_ix,j_ix] for (i_ix,i) in enumerate(species), (j_ix,j) in enumerate(species))\n\n################################################################################\n###### Showing the possible mean/variance of the portfolio by simulation #######\n################################################################################\n\nnSamples = 1000\nshares   = rand(nSamples,nSpecies)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Converting to probabilities","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"import BetaML.Utils:softmax\n[shares[i,:]  = softmax(shares[i,:], β=one.(shares[i,:]) .* 5) for i in 1:nSamples]\n\npScores = Array{Float64,2}(undef,0,2)\nfor i in 1:nSamples\n    global pScores\n    pVar    = sum(shares[i,j1] * shares[i,j2] * σ[species[j1],species[j2]] for j1 in 1:nSpecies, j2 in 1:nSpecies)\n    pY      = sum(shares[i,j]*y[species[j]] for j in 1:nSpecies)\n    pScores = vcat(pScores,[pVar pY])\nend\n\n#goodShares = [0,0,0.74,0.26]\n#pVar = sum(goodShares[j1] * goodShares[j2] * σ[species[j1],species[j2]] for j1 in 1:nSpecies, j2 in 1:nSpecies)\n#pY   = sum(goodShares[j]*y[species[j]] for j in 1:nSpecies)\n\nscatter(pScores[:,1],pScores[:,2],colour=:blue)\n\n################################################################################\n### Finding (one) optimal portfolio ############################################\n################################################################################","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Risk aversion coefficient","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"α = 0.1","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"We declare an optimisation problem, we name it \"m\" and we let JuMP associate it with the most suitable solver within the one installed:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"port = Model(Ipopt.Optimizer)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"We declare a set of variables, indicized by the species name:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"@variables port begin\n    x[i in species] >= 0\nend","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"We declare the constraint shat the sum of shares must be equal to 1","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"@constraint(port, c_share, sum(x[i] for i in species) == 1)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"@objective port Min begin   α *  sum(x[i] * x[j] * σ[i,j] for i in species for j in species) - sum(x[i] * y[i] for i in species) end","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"@NLobjective port Min α *  sum(x[i] * x[j] * σ[i,j] for i in species for j in species) - sum(x[i] * y[i] for i in species)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Print the optimisation model in nice human-readable format:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"print(port)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Solve the model and return the solving status:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"optimize!(port)\nstatus = termination_status(port)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Return the objective:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"println(\"Objective value: \", objective_value(port))","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"Return the value of the decision variable:","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"optShares = value.(x)\n[println(\"$sp = $(optShares[sp])\") for sp in species];\npOptVar = sum(optShares[species[j1]] * optShares[species[j2]] * σ[species[j1],species[j2]] for j1 in 1:nSpecies, j2 in 1:nSpecies)\npOptY   = sum(optShares[species[j]]*y[species[j]] for j in 1:nSpecies)\n\n\nfunction computeOptimalPortfolio(species,y,σ,α)\n    port = Model(Ipopt.Optimizer)\n    set_optimizer_attribute(port, \"print_level\", 0)\n    @variables port begin\n        x[i in species] >= 0\n    end\n    @constraint(port, c_share, sum(x[i] for i in species) == 1)\n    @NLobjective port Min α *  sum(x[i] * x[j] * σ[i,j] for i in species for j in species) - sum(x[i] * y[i] for i in species)\n    optimize!(port)\n    status = termination_status(port)\n    optShares = value.(x)\n    pOptVar = sum(optShares[species[j1]] * optShares[species[j2]] * σ[species[j1],species[j2]] for j1 in 1:nSpecies, j2 in 1:nSpecies)\n    pOptY   = sum(optShares[species[j]]*y[species[j]] for j in 1:nSpecies)\n    return (pOptVar,pOptY)\nend\n\nαs = [1000,100,10,1,0.1,0.05,0.02,0.01]\npOptScores = Array{Float64,2}(undef,0,2)\nfor α in αs\n    global pOptScores\n    pVar,pY =computeOptimalPortfolio(species,y,σ,α)\n    pOptScores = vcat(pOptScores,[pVar pY])\nend\nscatter!(pOptScores[:,1],pOptScores[:,2],colour=:red)\n\nαs = [82.45,50,30,20,15,12,10,9,8,7,6,5]\npOptScores = Array{Float64,2}(undef,0,2)\nfor α in αs\n    global pOptScores\n    pVar,pY =computeOptimalPortfolio(species,y,σ,α)\n    pOptScores = vcat(pOptScores,[pVar pY])\nend\n\nscatter(pOptScores[:,1],pOptScores[:,2],colour=:red)","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"View this file on Github.","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"","category":"page"},{"location":"02_-_JULIA2_-_Scientific_programming_with_Julia/0202-further_topics.html","page":"0202-further topics","title":"0202-further topics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html#Introduction-to-Scientific-Programming-and-Machine-Learning-with-Julia","page":"Index","title":"Introduction to Scientific Programming and Machine Learning with Julia","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"This site contains the scripts discussed in the video.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"GitHub repository\nYouTube playlist","category":"page"}]
}
